문제 회고를 위해 알고리즘 풀이 기록을 남깁니다.

# 백준 2042 구간 합 구하기

### 문제 이해하기
1. N <= 1000000개의 수가 주어진다.
2. 중간에 수의 변경이 M <= 10000번 변경된다.
3. 구간합을 출력하도록 K <= 10000번 호출된다.
4. 인풋의 각 값은 -2^63 <= out < 2^63이다. 
 
 
### 문제 접근 방법
1. N이 크므로 당연히 완전탐색은 불가능하다. O(NNMK)
2. dp를 이용한 구간합 또한 O(N+MN+K)로 시간복잡도가 매우크다.
3. N이 매우 크므로 기본적으로 O(1) 또는 O(log N) 또는 O(N)의 시간 복잡도를 고려해야한다.
4. 트리구조를 이용해서 O(logN)의 아이디어를 떠올려보자
5. 펜윅트리 또는 세그먼트 트리를 이용해 O(logN+K+M)의 연산을 해보자


### 구현 배경 지식
1. 세그먼트 트리
2. 펜윅트리
3. 구간합


### 접근 방법을 적용한 코드 - 펜윅 트리
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class bj_2042 {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		StringBuilder sb = new StringBuilder();
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());

		long[] A = new long[n + 1];
		long[] tree = new long[n + 1];
		for (int i = 1; i <= n; i++) {
			A[i] = Long.parseLong(br.readLine());
			update(tree, i, A[i]);
		}

		for (int i = 0; i < m + k; i++) {
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			long c = Long.parseLong(st.nextToken());
			if (a == 1) {
				// b번째 수를 c로 변경
				// 영향 받는 구간 먼저 변경 후
				update(tree, b, c - A[b]);
				// A 반영
				A[b] = c;
			} else {
				// b부터 c번째 수까지 합을 구함
				sb.append(sum(tree, (int) c) - sum(tree, b - 1)).append('\n');
			}
		}

		System.out.println(sb);

	}

	private static long sum(long[] tree, int b) {

		long result = 0;
		// 마지막 1 제거하며 진행
		while (b > 0) {
			result += tree[b];
			b -= (b & -b);
		}

		return result;
	}

	// b번째 수를 c로 변경
	private static void update(long[] tree, int b, long diff) {

		// 마지막 1이 영향을 주는데 까지 Tree 업데이트
		// 마지막 1의 값을 추가하며 진행
		while (b < tree.length) {
			tree[b] += diff;
			b += (b & -b);
		}
	}
}

```

### 접근 방법을 적용한 코드 - 세그먼트 트리
```java

```